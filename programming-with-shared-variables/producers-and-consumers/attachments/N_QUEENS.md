# Задача о N ферзях: история, алгоритм, реализация и продюсер–консюмер

---

## История задачи

- 1848 - задача о 8 ферзях опубликована в немецком шахматном журнале (Макс Беззель).
- 1850 - Франц Наук обобщил на размер NxN (задача о N ферзях).
- 1874 - Глейшер перечислил 92 решения для 8x8 (12 фундаментальных без учета симметрий).
- Факты:
    - N=1 - 1 решение.
    - N=2 и N=3 - решений нет.
    - Для всех N≥4 - решения существуют.

---

## Формулировка задачи

- Дано: шахматная доска NxN.
- Требуется: разместить N ферзей так, чтобы ни один не бил другой:
    - по строкам;
    - по столбцам;
    - по диагоналям.
- Что обычно просят:
    - найти все решения/одно решение;
    - сосчитать количество;
    - вывести координаты;
    - визуализировать.

---

## Backtracking (поиск с откатом)

- Метод перебора, который:
    - строит решение по шагам (по одному выбору за раз);
    - при конфликте “откатывается” к предыдущему выбору и пробует следующий вариант.
- В N-ферзях:
    - идем по строкам сверху вниз;
    - в каждой строке пробуем все столбцы;
    - если ход безопасен - углубляемся (рекурсия), иначе - следующий столбец;
    - если в строке все перепробовано - откат на строку выше.
- Почему эффективно: ранние проверки безопасности "отрезают" целые поддеревья поиска.

---

## Алгоритм решения

- Инициализировать пустую доску.
- Рекурсивная функция `solve(row)`:
    - если `row == N` -> фиксируем решение (печать + картинка);
    - иначе перебрать `col=0..N-1`:
        - если `isSafe(row, col)` -> поставить ферзя, вызвать `solve(row+1)`, снять ферзя (откат).
- Проверка `isSafe(row, col)`:
    - столбец выше;
    - левая верхняя диагональ;
    - правая верхняя диагональ.

---

## Проверка безопасности

```cpp
bool isSafe(int board[MAX_N][MAX_N], const int row, const int col, const int N) {
    for (int i = 0; i < row; i++) {              // столбец выше
        if (board[i][col] == 1) return false;
    }
    for (int i = row - 1, j = col - 1;           // диагональ влево-вверх
         i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 1) return false;
    }
    for (int i = row - 1, j = col + 1;           // диагональ вправо-вверх
         i >= 0 && j < N; i--, j++) {
        if (board[i][j] == 1) return false;
    }
    return true;
}
```

---

## Рекурсия и откаты

```cpp
void solve(int board[MAX_N][MAX_N], const int row, const int N) {
    if (row == N) {                      // база: найдено решение
        solutionCount++;
        printQueenPositions(board, N);   // вывод координат
        saveBoardAsImage(board, N);      // PNG
        return;
    }
    for (int col = 0; col < N; col++) {  // перебор столбцов
        if (isSafe(board, row, col, N)) {
            board[row][col] = 1;         // выбор
            solve(board, row + 1, N);    // углубление
            board[row][col] = 0;         // откат
        }
    }
}
```

---

## Вывод координат решения

```cpp
void printQueenPositions(int board[MAX_N][MAX_N], int N) {
    cout << solutionCount << ": ";
    bool first = true;
    for (int i = 0; i < N; i++) {                // по строкам
        for (int j = 0; j < N; j++) {            // по столбцам
            if (board[i][j] == 1) {              // нашли ферзя
                if (!first) cout << ", ";
                cout << "(" << i << ", " << j << ")";
                first = false;
                break;                            // в строке ровно один ферзь
            }
        }
    }
    cout << endl;
    cout.flush();                                  // по мере готовности
}
```

---

## Простая визуализация (PNG 256x256)

```cpp
void saveBoardAsImage(int board[MAX_N][MAX_N], const int N) {
    constexpr int size = 256, colors = 3;
    auto* pixels = new unsigned char[size * size * colors];

    const unsigned char white[3] = {255,255,255};
    const unsigned char black[3] = {0,0,0};
    const unsigned char qween[3] = {255,0,0}; // ферзь - красный

    for (int y = 0; y < size; y++) {
        int r = y * N / size;                 // строка клетки
        for (int x = 0; x < size; x++) {
            int c = x * N / size;             // столбец клетки
            const unsigned char* color =
                (board[r][c] == 1) ? qween : (((r + c) % 2 == 0) ? white : black);
            int idx = (y * size + x) * colors;
            pixels[idx+0] = color[0];
            pixels[idx+1] = color[1];
            pixels[idx+2] = color[2];
        }
    }

    char filename[512];
    sprintf(filename, "%s/solution_%04d.png", outputDir, solutionCount);
    stbi_write_png(filename, size, size, colors, pixels, size * colors);
    delete[] pixels;
}
```

---

## Общая идея реализации

- Простые структуры данных: `board[MAX_N][MAX_N]` с 0/1.
- Четкое разделение обязанностей:
    - `isSafe` - локальная проверка;
    - `solve` - генератор решений (backtracking);
    - `printQueenPositions` - человекочитаемый вывод сразу по готовности;
    - `saveBoardAsImage` - простая отрисовка через `stb_image_write`.
- Результаты сохраняются в `./solves/N/`, относительно бинарника, и печатаются в консоль.

---

## queue и condition_variable

- queue (очередь):
    - структура данных "первым пришел - первым вышел" (FIFO);
    - используется для передачи задач/данных между частями программы (или потоками).
- condition_variable (условная переменная):
    - механизм синхронизации потоков;
    - позволяет одному потоку "ждать события" (например, пока очередь не станет непустой), а другому - "будить" (послать
      сигнал), когда событие произошло.
- Вместе с mutex обеспечивают безопасный обмен данными между потоками без активного ожидания.

---

## Как встроить модель "производитель–потребитель"

- Где производитель:
    - Внутри `solve`, в базовом случае `row == N`.
    - Вместо прямых вызовов `printQueenPositions(...)` и `saveBoardAsImage(...)`:
        - брать "снимок" текущего `board` (NxN);
        - класть его в очереди задач: одну для печати, вторую - для картинок;
        - присваивать решением сквозной `id` (номер) и передавать его вместе с данными.
- Где потребители:
    - Два отдельных потока, запущенных в `main()`:
        - поток печати: извлекает из очереди и вызывает `printQueenPositions(..., id)`;
        - поток картинок: извлекает и вызывает `saveBoardAsImage(..., id)`.
- Что добавить в `main()`:
    - Инициализировать очереди (с mutex и condition_variable).
    - Запустить два потока-потребителя до вызова `solve(...)`.
    - После завершения `solve()` отправить в каждую очередь "сентинел" (спец-маркер конца).
    - Вызвать `join()` у потоков, чтобы корректно завершить программу.
- Важные нюансы:
    - Снимок board обязателен: после выхода из solve начнутся откаты, и состояние изменится.
    - Нумерацию решений лучше делать в одном месте (в solve), чтобы и консоль, и имена файлов совпадали.
    - Папки (“./solves” и “./solves/N”) - создавать в main до старта потоков.
