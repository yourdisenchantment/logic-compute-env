```cpp
// ./programming-with-shared-variables/recursive-parallelism/multi-thread-app-ii.cpp


#include <cmath>
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>

using namespace std;

constexpr double R = 1;
constexpr double eps = 1e-7;

double f(double x);
void integrate(double a, double b, double fa, double fb, double* s);

double f(const double x) {
    return sqrt(R * R - x * x);
}

mutex mtx;
atomic<int> current_threads(0);
atomic<int> max_threads(0);

void integrate(const double a, const double b, const double fa, const double fb, double* s) {
    {
        lock_guard<mutex> lock(mtx);
        current_threads++;
        if (current_threads > max_threads) {
            max_threads = current_threads;
        }
    }

    double m = (a + b) / 2;
    double fm = f(m);

    double sl = (m - a) * (fa + fm) / 2;
    double sr = (b - m) * (fm + fb) / 2;

    if (abs(sl + sr - *s) < eps * 3) {
        *s = sl + sr;
        lock_guard<mutex> lock(mtx);
        current_threads--;
        return;
    }

    thread tl([&]() { integrate(m, b, fm, fb, &sl); });
    thread tr([&]() { integrate(a, m, fa, fm, &sr); });

    tl.join();
    tr.join();

    *s = sl + sr;
    {
        lock_guard<mutex> lock(mtx);
        current_threads--;
    }
}

int main() {
    constexpr double a = 0;
    constexpr double b = R;

    const double fa = f(a);
    const double fb = f(b);

    double s = (b - a) * (fa + fb) / 2;
    integrate(a, b, fa, fb, &s);

    constexpr double area = M_PI * R * R / 4;
    const double error = abs(s - area);

    cout << "Calculated area: " << s << endl;
    cout << "Expected area: " << area << endl;
    cout << "Error: " << error << endl;
    cout << "Max threads: " << max_threads << endl;
    cout << "Current threads: " << current_threads << endl;
}
```

Основные изменения:

1.  **Добавлены переменные для отслеживания потоков:**
    *   `current_threads`:  `atomic<int>`, считает количество работающих потоков. Используем `atomic` для безопасного доступа из разных потоков.
    *   `max_threads`: `atomic<int>`, хранит максимальное количество потоков, работавших одновременно.  Тоже `atomic`.
    *   `mtx`:  `mutex` для защиты доступа к `current_threads` и `max_threads`.
2.  **Обновление счётчиков потоков в `integrate`:**
    *   В начале `integrate`:
        *   Блокируем мьютекс `mtx`.
        *   Увеличиваем `current_threads` на 1.
        *   Если `current_threads` больше, чем `max_threads`, то обновляем `max_threads`.
        *   Мьютекс автоматически освобождается при выходе из блока `lock_guard`.
    *   В конце `integrate`:
        *   Снова блокируем мьютекс.
        *   Уменьшаем `current_threads` на 1.
        *   Мьютекс освобождается.
3.  **Вывод результатов в `main`:**  Добавлены строки для вывода `max_threads` и `current_threads` в конце программы.
4. **Использование `lock_guard`:** Использование `lock_guard` обеспечивает автоматическое освобождение мьютекса при выходе из области видимости, даже если происходит исключение.

Важные моменты:

*   **Atomic:**  Использование `atomic<int>` для `current_threads` и `max_threads` позволяет безопасно читать и изменять их значения из разных потоков.  В противном случае, гонки данных могли бы приводить к некорректным результатам.
*   **Мьютекс:** `mutex` обеспечивает эксклюзивный доступ к переменным `current_threads` и `max_threads`. Без мьютекса несколько потоков могли бы одновременно пытаться изменить значения этих переменных, что привело бы к непредсказуемым результатам.
*   **Порядок операций:** Важно, чтобы увеличение `current_threads` происходило до создания новых потоков, а уменьшение - после их завершения.  Это гарантирует, что `current_threads` всегда будет правильно отражать количество работающих потоков.
*   **`lock_guard`:**  `lock_guard` - это RAII-класс, который автоматически захватывает мьютекс при создании и освобождает его при уничтожении (когда `lock_guard` выходит из области видимости).  Это упрощает управление мьютексами и предотвращает забывание освободить мьютекс.
* **Лямбда-функция для thread:** Использование лямбда-функции для создания потоков позволяет захватывать переменные по ссылке (`[&]`), что необходимо для корректной передачи параметров в функцию `integrate`.

Этот код корректно отслеживает количество потоков и использует мьютексы для защиты общих переменных, обеспечивая правильную работу даже при высокой степени параллелизма.  Он также более безопасен благодаря использованию `lock_guard`.

---

```cpp
// ./programming-with-shared-variables/recursive-parallelism/multi-thread-app-ii.cpp


#include <cmath>
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>

using namespace std;

constexpr double R = 1;
constexpr double eps = 1e-7;

double f(double x);
void integrate(double a, double b, double fa, double fb, double* s);

double f(const double x) {
    return sqrt(R * R - x * x);
}

mutex mtx;
atomic<int> current_threads(0);
atomic<int> max_threads(0);

void integrate(const double a, const double b, const double fa, const double fb, double* s) {
    {
        lock_guard<mutex> lock(mtx);
        current_threads++;
        if (current_threads > max_threads) {
            max_threads = current_threads;
        }
    }

    double m = (a + b) / 2;
    double fm = f(m);

    double sl = (m - a) * (fa + fm) / 2;
    double sr = (b - m) * (fm + fb) / 2;

    if (abs(sl + sr - *s) < eps * 3) {
        *s = sl + sr;
        lock_guard<mutex> lock(mtx);
        current_threads--;
        return;
    }

    thread tl([&]() { integrate(m, b, fm, fb, &sl); });
    thread tr([&]() { integrate(a, m, fa, fm, &sr); });

    tl.join();
    tr.join();

    *s = sl + sr;
    {
        lock_guard<mutex> lock(mtx);
        current_threads--;
    }
}

int main() {
    constexpr double a = 0;
    constexpr double b = R;

    const double fa = f(a);
    const double fb = f(b);

    double s = (b - a) * (fa + fb) / 2;
    integrate(a, b, fa, fb, &s);

    constexpr double area = M_PI * R * R / 4;
    const double error = abs(s - area);

    cout << "Calculated area: " << s << endl;
    cout << "Expected area: " << area << endl;
    cout << "Error: " << error << endl;
    cout << "Max threads: " << max_threads << endl;
    cout << "Current threads: " << current_threads << endl;
}
```

Основные изменения:

1.  **Добавлены переменные для отслеживания потоков:**
    *   `current_threads`:  `atomic<int>`, считает количество работающих потоков. Используем `atomic` для безопасного доступа из разных потоков.
    *   `max_threads`: `atomic<int>`, хранит максимальное количество потоков, работавших одновременно.  Тоже `atomic`.
    *   `mtx`:  `mutex` для защиты доступа к `current_threads` и `max_threads`.
2.  **Обновление счётчиков потоков в `integrate`:**
    *   В начале `integrate`:
        *   Блокируем мьютекс `mtx`.
        *   Увеличиваем `current_threads` на 1.
        *   Если `current_threads` больше, чем `max_threads`, то обновляем `max_threads`.
        *   Мьютекс автоматически освобождается при выходе из блока `lock_guard`.
    *   В конце `integrate`:
        *   Снова блокируем мьютекс.
        *   Уменьшаем `current_threads` на 1.
        *   Мьютекс освобождается.
3.  **Вывод результатов в `main`:**  Добавлены строки для вывода `max_threads` и `current_threads` в конце программы.
4. **Использование `lock_guard`:** Использование `lock_guard` обеспечивает автоматическое освобождение мьютекса при выходе из области видимости, даже если происходит исключение.

Важные моменты:

*   **Atomic:**  Использование `atomic<int>` для `current_threads` и `max_threads` позволяет безопасно читать и изменять их значения из разных потоков.  В противном случае, гонки данных могли бы приводить к некорректным результатам.
*   **Мьютекс:** `mutex` обеспечивает эксклюзивный доступ к переменным `current_threads` и `max_threads`. Без мьютекса несколько потоков могли бы одновременно пытаться изменить значения этих переменных, что привело бы к непредсказуемым результатам.
*   **Порядок операций:** Важно, чтобы увеличение `current_threads` происходило до создания новых потоков, а уменьшение - после их завершения.  Это гарантирует, что `current_threads` всегда будет правильно отражать количество работающих потоков.
*   **`lock_guard`:**  `lock_guard` - это RAII-класс, который автоматически захватывает мьютекс при создании и освобождает его при уничтожении (когда `lock_guard` выходит из области видимости).  Это упрощает управление мьютексами и предотвращает забывание освободить мьютекс.
* **Лямбда-функция для thread:** Использование лямбда-функции для создания потоков позволяет захватывать переменные по ссылке (`[&]`), что необходимо для корректной передачи параметров в функцию `integrate`.

Этот код корректно отслеживает количество потоков и использует мьютексы для защиты общих переменных, обеспечивая правильную работу даже при высокой степени параллелизма.  Он также более безопасен благодаря использованию `lock_guard`.

---

```cpp
// ./programming-with-shared-variables/recursive-parallelism/multi-thread-app-ii.cpp

#include <cmath>
#include <iostream>
#include <mutex>
#include <thread>

using namespace std;

constexpr double R = 1;
constexpr double eps = 1e-7;

double f(double x);
void integrate(double a, double b, double fa, double fb, double* s, bool is_top);

mutex mtx;
int current_threads = 1;
int max_threads = 1;

double f(const double x) {
    return sqrt(R * R - x * x);
}

void integrate(const double a, const double b, const double fa, const double fb, double* s, bool is_top) {
    if (!is_top) {
        lock_guard<mutex> lock(mtx);
        current_threads++;
        if (current_threads > max_threads) {
            max_threads = current_threads;
        }
    }

    double m = (a + b) / 2;
    double fm = f(m);

    double sl = (m - a) * (fa + fm) / 2;
    double sr = (b - m) * (fm + fb) / 2;

    if (abs(sl + sr - *s) < eps * 3) {
        *s = sl + sr;
        if (!is_top) {
            lock_guard<mutex> lock(mtx);
            current_threads--;
        }
        return;
    }

    auto t1 = thread(integrate, a, m, fa, fm, &sl, false);
    auto t2 = thread(integrate, m, b, fm, fb, &sr, false);

    t1.join();
    t2.join();

    *s = sl + sr;
    if (!is_top) {
        lock_guard<mutex> lock(mtx);
        current_threads--;
    }
}

int main() {
    constexpr double a = 0;
    constexpr double b = R;

    const double fa = f(a);
    const double fb = f(b);

    double s = (b - a) * (fa + fb) / 2;
    integrate(a, b, fa, fb, &s, true);

    constexpr double area = M_PI * R * R / 4;
    const double error = abs(s - area);

    cout << s << endl;
    cout << area << endl;
    cout << error << endl;
    cout << current_threads << endl;
    cout << max_threads << endl;
}
```
